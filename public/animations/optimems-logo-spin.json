{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"gradient","usesPingPong":false,"speed":0.25,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos;vec3 getColor(int index) {\nswitch(index) {\ncase 0: return vec3(0, 0, 0);\ncase 1: return vec3(0, 0, 0);\ncase 2: return vec3(0, 0, 0);\ncase 3: return vec3(0, 0, 0);\ncase 4: return vec3(0, 0, 0);\ncase 5: return vec3(0, 0, 0);\ncase 6: return vec3(0, 0, 0);\ncase 7: return vec3(0, 0, 0);\ncase 8: return vec3(0, 0, 0);\ncase 9: return vec3(0, 0, 0);\ncase 10: return vec3(0, 0, 0);\ncase 11: return vec3(0, 0, 0);\ncase 12: return vec3(0, 0, 0);\ncase 13: return vec3(0, 0, 0);\ncase 14: return vec3(0, 0, 0);\ncase 15: return vec3(0, 0, 0);\ndefault: return vec3(0.0);\n}\n}const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) {\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec2(\ncoord.x * c - coord.y * s,\ncoord.x * s + coord.y * c\n);\n}out vec4 fragColor;vec3 getColor(vec2 uv) {return vec3(0, 0, 0);\n}void main() {vec2 uv = vTextureCoord;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nuv -= pos;\nuv /= max(0.5000*2., 1e-5);\nuv = rotate(uv, (0.0000 - 0.5) * 2. * PI);\nvec4 color = vec4(getColor(uv), 1.0000);\nfragColor = color;\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}"],"data":{"downSample":0.5,"depth":false,"uniforms":{},"isBackground":true},"id":"gradient"},{"breakpoints":[{"min":992,"name":"Desktop","max":null,"props":{"scale":0.23}},{"props":{"scale":0.18},"max":575,"name":"Mobile","min":0}],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"sdf_shape","usesPingPong":false,"texture":{"src":"https://assets.unicorn.studio/images/ldoKRzHepkRj9icRCErLhMwqpIi1/optimems_combined_1769066610172.png","sampler":"uCustomTexture"},"speed":0.24,"trackMouseMove":0.08,"trackAxes":"xy","mouseMomentum":0.5,"trackMouse":0.5,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform sampler2D uCustomTexture;uniform float uScale;\nuniform float uTime;uniform vec2 uMousePos;\nuniform vec2 uResolution;uvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}const float PI = 3.141592653;\nconst float PI2 = 6.283185306;\nconst int DISP_STEPS = 12;\nconst vec3 viewDir = vec3(0,0, -4.25);ivec2 customTexSize;\nfloat customTexAspect;const mat3 ROT_Y_90 = mat3(\n0.0, 0.0, 1.0,\n0.0, 1.0, 0.0,\n-1.0, 0.0, 0.0\n);const mat3 ROT_Z_90 = mat3(\n0.0, -1.0, 0.0,\n1.0, 0.0, 0.0,\n0.0, 0.0, 1.0\n);const mat3 ROT_X_90 = mat3(\n1.0, 0.0, 0.0,\n0.0, 0.0, -1.0,\n0.0, 1.0, 0.0\n);mat3 rotY(float ang) {\nfloat c = cos(ang), s = sin(ang);\nreturn mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\n}mat3 rotX(float ang) {\nfloat c = cos(ang), s = sin(ang);\nreturn mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\n}mat3 rotZ(float ang) {\nfloat c = cos(ang), s = sin(ang);\nreturn mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n}vec3 twistY(vec3 p, float amount) {\nfloat c = cos(amount * p.y);\nfloat s = sin(amount * p.y);\nmat2 m = mat2(c, -s, s, c);\nreturn vec3(m * p.xz, p.y);\n}vec3 twistX(vec3 p, float amount) {\nfloat c = cos(amount * p.x);\nfloat s = sin(amount * p.x);\nmat2 m = mat2(c, -s, s, c);\nreturn vec3(p.x, m * p.yz);\n}float opExtrusion(vec3 p, float d, float h) {\nvec2 w = vec2( d, abs(p.z) - h );\nreturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}float sdStar5(vec2 p, float r, float rf)\n{\nconst vec2 k1 = vec2(0.809016994375, -0.587785252292);\nconst vec2 k2 = vec2(-k1.x,k1.y);\np.x = abs(p.x);\np -= 2.0*max(dot(k1,p),0.0)*k1;\np -= 2.0*max(dot(k2,p),0.0)*k2;\np.x = abs(p.x);\np.y -= r;\nvec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\nfloat h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\nreturn length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}float median(float r, float g, float b) {\nreturn max(min(r, g), min(max(r, g), b));\n}float sdCustom(vec3 p) {\np *= rotX(radians(90.0));\np *= rotY(radians(180.0));\np *= rotZ(radians(180.0));\nvec2 uv = p.xy * 0.25 + 0.5;\nif (customTexAspect > 1.0) {\nuv.y = (uv.y - 0.5) * customTexAspect + 0.5;\n} else {\nuv.x = (uv.x - 0.5) / customTexAspect + 0.5;\n}vec4 sdColor = texture(uCustomTexture, uv);\nfloat msdf = median(sdColor.r, sdColor.g, sdColor.b);\nfloat sdf = sdColor.a;\nfloat sd = msdf;\nif(sdf < 1.) {\nfloat tuning = 0.023;\nsd = mix(msdf, max(msdf - tuning, sdf), sdf);\n}float screenPxDistance = sd - 0.5;\nfloat d = -screenPxDistance;return opExtrusion(p, d, 0.2500 * 0.5);\n}vec3 getRepeat(vec3 p) {\nfloat spacing = (0.5000 + 0.0000 * 0.38) * 8.;\nreturn p;\n}vec3 getThreeDRepeat(vec3 p) {\nfloat spacing = (0.5000 + 0.0000 * 0.38) * 8.;\nreturn p;\n}vec3 getAdjustedP(vec3 p) {\nfloat scale = max(uScale, 0.000000001);\nfloat scaleFactor = 1.0/scale;\nvec3 adjustedP = p * scaleFactor;vec2 twist = vec2(0, 0);adjustedP.xy *= vec2(uResolution.x / uResolution.y, 1);adjustedP *= (1. + (0.0000 + 0.01));vec2 mousePos = mix(vec2(0), uMousePos - 0.5, 0.5000);\nvec2 axis = vec2(-1. * vec3(0, 0, 0).y - 1. + mousePos.y/PI, vec3(0, 0, 0).x + mousePos.x/PI) * 2.;adjustedP = getRepeat(adjustedP);float baseTime = uTime * 0.02;\nfloat timeX = vec3(0, 1, 0).x * baseTime;\nfloat timeY = vec3(0, 1, 0).y * baseTime;\nfloat timeZ = vec3(0, 1, 0).z * baseTime;mat3 rotYMat = rotY(axis.y * PI);\nmat3 rotXMat = rotX(axis.x * PI);\nmat3 rotZMat = rotZ(vec3(0, 0, 0).z * 2.0 * PI);mat3 combinedRotation = rotZMat * rotYMat * rotXMat;\nmat3 combinedAnimation = rotZ(timeZ) * rotX(timeX) * rotY(timeY);adjustedP = combinedRotation * adjustedP;\nadjustedP = combinedAnimation * adjustedP;\nadjustedP = getThreeDRepeat(adjustedP);\nadjustedP = mix(adjustedP, twistY(adjustedP, -1.0 * twist.y), step(0.0, abs(twist.y)));\nadjustedP = mix(adjustedP, twistX(adjustedP, -1.0 * twist.x), step(0.0, abs(twist.x)));return adjustedP;\n}float getMergedSDF(vec3 p) {\np = getAdjustedP(p);\nreturn sdCustom(p);\n}float fresnel(vec3 eyeVector, vec3 worldNormal, float power) {\nfloat NdotV = abs(dot(eyeVector, worldNormal));\nfloat width = fwidth(dot(eyeVector, worldNormal));\nfloat threshold = 0.2;\nfloat edgeDampFactor = smoothstep(threshold, -threshold, width);\nfloat fresnelFactor = 1.0 - NdotV;\nreturn pow(fresnelFactor, power) * mix(1., edgeDampFactor * 2., 0.5);\n}vec3 calculateNormal(vec3 p, float eps) {\nvec2 e = vec2(1.0, -1.0) * eps * 0.5;\nreturn normalize(\ne.xyy * getMergedSDF(p + e.xyy) +\ne.yyx * getMergedSDF(p + e.yyx) +\ne.yxy * getMergedSDF(p + e.yxy) +\ne.xxx * getMergedSDF(p + e.xxx)\n);\n}float scene(vec3 p) {\nreturn max(0.0000000001, getMergedSDF(p) - (0.0000 + 0.005)) * max(uScale, 0.000000001);\n}const int STEPS = 128;\nconst float MAX_DISTANCE = 100.0;vec4 rayMarch(vec3 ro, vec3 rd) {\nfloat pixelSize = 0.0025;\nfloat traveled = 0.;\nvec3 entryPoint = vec3(0.0);\nvec3 entryNormal = vec3(0.0);\nfloat partialAlpha = 0.0;\nfloat lastDistance = 0.0;\nfloat smoothing = mix(1., 4., 0.2000);for (int i = 0; i < STEPS; ++i) {\nvec3 currentPos = ro + rd * traveled;\nfloat distance = scene(currentPos);\nfloat progress = float(i)/float(STEPS);\nfloat step = distance * mix(1., 1.5, progress);if (distance > MAX_DISTANCE) break;if (distance < pixelSize) {\npartialAlpha = 1.;\nentryPoint = currentPos;\nentryNormal = calculateNormal(entryPoint, pixelSize * smoothing);\nbreak;\n}lastDistance = distance;traveled += max(step, pixelSize);\nif (traveled > MAX_DISTANCE) break;\n}if (partialAlpha == 0.0) {\nreturn vec4(0);\n}vec3 samplePosition = mix(rd, entryPoint, 1.0000);vec3 refractionColor = texture(uTexture, vTextureCoord).rgb;\nvec3 lightDir = vec3(((vec2(vec3(0.25, 0.25, -3).x, 1.-vec3(0.25, 0.25, -3).y) - 0.333) * 3.) - vec2(0.5, 0.5), vec3(0.25, 0.25, -3).z);\nvec3 normLightDir = normalize(lightDir);float lightAndShadow = dot(entryNormal, normLightDir);\nvec3 lightColor = mix(vec3(1), vec3(0.9098039215686274, 0.34509803921568627, 0.32941176470588235), 1. - 1.0000);\nvec3 fresnelEffect = vec3(0.0);fresnelEffect = fresnel(rd, entryNormal, 8.0) * 1.0000 * vec3(0.9098039215686274, 0.34509803921568627, 0.32941176470588235);vec3 specularEffect = vec3(0.0);vec3 halfwayDir = normalize(lightDir + rd);\nfloat specFactor = pow(max(dot(entryNormal, halfwayDir), 0.0), 64.0 * 1.0000 + 0.01);\nspecularEffect = specFactor * 1.0000 * lightColor;vec3 combinedEffects = fresnelEffect + specularEffect;\nvec3 finalColor = mix(refractionColor, vec3(0.9098039215686274, 0.34509803921568627, 0.32941176470588235) * lightAndShadow, 1.0000);\nfinalColor += combinedEffects;vec4 outputColor = vec4(finalColor, 1.);return outputColor;\n}out vec4 fragColor;void main() {\nvec4 col = vec4(0);\nvec4 bg = texture(uTexture, vTextureCoord);customTexSize = textureSize(uCustomTexture, 0);\ncustomTexAspect = float(customTexSize.x) / float(customTexSize.y);if(float(customTexSize.x) == float(uResolution.x) && float(customTexSize.y) == float(uResolution.y)) {\ndiscard;\n}if(uScale <= 0.0001 || 1.0000 <= 0.0001) {\ncol = vec4(0);\nif(0 == 1) {\ncol = bg;\n}\nfragColor = col;\nreturn;\n}vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0800);\nvec2 uv = vTextureCoord - pos;\nfloat fovFactor = tan(radians(20.) * 0.5);\nvec3 rd = vec3(uv * fovFactor, 0.5);\ncol = rayMarch(viewDir, rd);\nfloat dither = (randFibo(vTextureCoord.xy) - 0.5) / 255.0;\ncol += dither;col = mix(vec4(0), col, 1.0000);\nfragColor = col;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{"scale":{"name":"uScale","type":"1f","value":0.5}},"isBackground":false},"id":"3d_shape"}],"options":{"name":"optimems-logo-spin","fps":60,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":true},"version":"2.0.2","id":"qzFpBtiNgWqiV4xgJGok"}